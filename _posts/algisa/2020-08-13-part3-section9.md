---
layout: post
title: 정보보안기사 - Part 03. 접근통제 (section 09. 사용자 인증)
category: 정보보안기사
tags: [정보보안기사, 접근통제, 인증]
comments: true
---
> 정보보안기사 알기사 1200제를 풀고 암기가 필요한 부분을 정리해 놓은 포스팅입니다.  
개인 공부후 자료를 남기기 위한 목점임으로 내용상에 오류가 있을 수 있습니다.

# Part 03. 접근통제 (section 09. 사용자 인증)
## 사용자 인증
- A와 B가 통신할 때, A가 B에게 자신이 A임을 증명

## 개별 식별
- A와 C가 통신할 때 B가 C에게 A인척 못하게 하는 것

## 메시지 출처 인증기술
1. `메시지를 암호화 하는 방법`
	1. `대칭키`를 이용한 암호화 $\to$ 기밀성 + `부분적인 인증(송신 부인방지)`
	2. `비대칭키`를 이용한 암호화
		1. `수신자의 공개키`로 암호화 $\to$ 기밀성
		2. `송신자의 개인키`로 암호화 $\to$ 인증과 부인방지
		3. `송신자의 개인키`로 암호화하고 `수신자의 공개키`로 암호화 $\to$ 기밀성 + 인증과 부인방지
2. `메시지 인증코드(MAC)`
- 메시지와 `대칭키`를 입력으로 만들어진 코드
- 사전에 송신자와 수신자 간에 **대칭키 공유**가 필요
- `비밀키`로 암호화하고 `공개키`로 복호화하는 `공개키 암호 시스템`을 이용
3. `해시함수`
- MAC과 달리 대칭키를 사용하지 않아 키교환이 필요 없음
- 해시함수 결과값 자체는 **기밀성이 없으므로** 암호화와 섞어서 사용

## 사용자 인증의 유형

| 유형 | 설명 | 예 |
|:-----:|:-----|:-----|
| Type1 (지식) | `Something you know` | 패스워드, PIN |
| Type2 (소유) | `Something you have`| 토큰, 스마트 카드 |
| Type3 (존재) | `Something you are` | 지문 |
| Type3 (행위) | `Something you do` | 서명, 움직임 |
| Tow Factor | 위 타입 중에서 2가지 인증 메커니즘을 결합하여 구현 | 토큰 + PIN |
| Multi Factor | 가장 강한 인증으로 세 가지 이상의 인증 메커니즘을 사용 | 토큰 + PIN + 지문인식 |

## 보안토큰(HSM, Hardware Security Module)
- 스마트 카드, USB 토큰
- 공인인증서나 개인키를 저장하는 용도
- 전자서명 생성키 등 비밀 정보를 안전하게 저장 및 보관

## 시도-응답  프로토콜
- `재연 공격`방지를 위해 `타임스탬프`, `세션 랜텀 값`, `순서번호`를 사용

## 패스워드 크래킹 툴
`Jonn the Ripper`, `pwdump`, `L0phtCrack`, `Wfuzz`, `Cain and Abel`, `THC Hydra`, `Brutus`, `RainbowCrack`, `Medusa`

| 도구 | 설명 |
|:-----:|:-----|
| Jonn the Ripper | - Solaris Designer가 개발한 Unix 계열 password crack tool<br>- 패스워드 점검도구로 가장 잘 알려진 프로그램(윈도우, 리눅스, Mac 지원) |
| pwdump | 윈도우에서 패스워드를 덤프(dump)할 수 있는 도구 |
| L0phtCrack | 패스워드 취약점 점검도구로 원격 및 로컬 서버나 PC에 대하여 패스워드를 점검하는데 유용 |
| Wfuzz | 웹 애플리케이션 패스워드 크래킹 툴(brute force 공격) |
| Cain and Abel | 매우 잘 알려진 윈도우 기반의 패스워드 크래킹 툴로 다양한 작업 수행 가능 |
| THC Hydra | 빠른 네트워크 로그인 패스워드 크래킹 툴 <br>- 모듈을 쉽게 추가해 기능을 향상시킴<br>- Windows, Linux, Free BSD, Solaris에서 사용 가능<br>- 다양한 네트워크 프로토콜 지원|

## Winnuke(blue bomb, nuking)
- `청색폭탄`, `누킹`이라고도 불림
- 처리 불가능한 과도한 양의 네트워크 대역을 넘어서는 패킷
- 이 패킷을 다른 시스템 사용자에게 전송함으로써 시스템 운영체제를 다운시킴
- 현재는 대부분의 ISP가 청색폭탄이 도달하기 전에 패킷을 필터링함

## 일회용 패스워드 방식
1. Challenge - Response 방식
2. Time Synchronous 방식
3. Event Synchronous 방식
4. S/Key 일회용 패스워드 방식

## 이벤트 동기화 방식
서버와 클라이언트가 카운드 값을 동일하게 증가시켜 가며, 카운트 값을 입력 값으로 OTP를 생성해 인증하는 방식

##  S/Key 방식
- 클라이언트에서 정한 임의의 비밀키를 서버로 전송
- 클라이언트로부터 받은 비밀키를 첫 값으로 사용해 해시 체인 방식으로 이전 결과값에 대한 해시값을 구하는 작업을 n번 반복
- 생성된 n개의 OTP를 서버에 저장

## 시도 - 응답 식별 프로토콜
1. 일방향 개인식별 프로토콜
2. 상호 개인식별 프로토콜
3. 영지식 기반 개인식별 프로토콜
	1. Flat-Shamir 개인식별 프로토콜
	매우 큰 두 소수의 곱을 법으로 하는 어떤 수에 대한 **제곱근의 계산**의 어려움에 기반
	2. Schnorr 개인식별 프로토콜
	매우 큰 소수를 법으로 하는 **이산대수 문제**의 어려움에 기반

## 거래연동 OTP
수신자 계좌번호, 송금액 등의 전자금용 정보와 연계하여 OTP를 발생시키는 것

## 원타임 패드(one-time pad)
- 암호화하려는 평문의 길이와 같거나 그보다 긴 길이의 임의의 난수열을 키로 사용
- 한번 사용한 키는 재사용하지 않는 `대칭키 암호 방식`
- 암호화 키와 복호화 키가 동일
- 키 교환이 필요
- 원타임 패드는 무조건 안전을 만족한다는 것을 샤논에 의해 수학적으로 증명됨

## 정적 데이터 인증
- 매회 인증할 때마다 같은 데이터를 사용하며, `출입카드`가 대표적
- 정적 데이터 인증을 위해서는 `발행자의 개인키`로 서명된 정적 응용 프로그램의 데이터와 `인증기관이 서명한 발행자의 공개키`를 저장하고 있어야 함

## 정적 데이터 인증 카드의 발행
1. 정적 응용 프로그램 데이터 : 카드 번호, 사용자 이름, 주소 등의 값을 설정
2. 서명된 정적 응용 프로그램 데이터 : `발행기관의 개인키`를 이용해 $(1)$을 서명(암호화)
3. `인증기관(CA)의 개인키`로 `발행자의 공개키`를 암호화
4. 인증 데이터 저장 : 서명된 정적 응용 프로그램 데이터$(2)$와 인증기관(CA)의 개인키로 발행자의 공개키를 암호화한 데이터$(3)$를 스마트 카드에 저장
5. `인증기관(CA)의 공개키`를 스마트 카드 단말에 배포

## 정적 데이터 인증 카드의 인증
1. `인증기관(CA)의 개인키`로 암호화된 `발행기관의 공개키`가 전달됨  
	전달된 `발행기관의 공개키`는 카드 단말기에 저장된 `인증기관의 공개키`로 복호화
2. 복호화된 `발행기관의 공개키`로 스마트카드에 저장된 '서명된 정적 응용 프로그램 데이터'를 복호화하여 카드 단말기는 '정적 응용 프로그램 데이터'를 확인

## 동적 데이터 인증
- 카드 단말기가 임의로 생성한 난수를 전송하면 스마트카드에 저장된 스마트카드의 개인키를 이용하여 서명한 결과를 전송
- 동적 데이터 인증방식은 별도의 **정적 데이터를 카드 내부에 저장**하며, `인증기관의 개인키로 서명한 발행자의 공개키`가 저장되어 있어야 함

## 동적 데이터 인증 카드의 발행
1. 정적 응용 프로그램 데이터 : 카드 번호, 사용자 이름, 주소 등의 값을 설정
2. 정적 응용 프로그램 데이터와 스마트카드의 공개키 서명 : `발행기관의 개인키`를 이용하여 $(1)$에서 설정한 **정적 응용 프로그램 데이터**와 **스마트카드의 공개키**를 서명(암호화)
3. `인증기관(CA)의 개인키`로 `발행자의 공개키`를 암호화
4. 인증 데이터 저장 : `스마트카드의 개인키`, `서명된 정적 응용 프로그램 데이터`$(2)$, `인증기관(CA)의 개인키`로 암호화한 `발행자의 공개키`는 스마트카드에 저장
5. `인증기관(CA)의 공개키`를 스마트카드 단말에 배포

## 동적 데이터 인증 카드의 인증
1. 카드 단말은 스마트카드에 임의로 생성한 난수와 기타 동적 데이터를 생성하여 스마트카드에 전송
2. 스마트카드는 본인의 `스마트카드 개인키`를 사용하여 $(1)$에서 전달받은 데이터와 기타 응용 프로그램 데이터를 서명(암호화)하여 카드 단말에 전달
3. `인증기관(CA)의 개인키`로 암호화된 `발행기관의 공개키`가 전달됨  
	전달된 `발행기관의 공개키`는 카드 단말기에 저장된 `인증기관의 공개키`로 복호화
4. 복호화된 `발행기관의 공개키`로 스마트카드에 저장된 '서명된 정적 응용 프로그램 데이터'를 복호화하여 카드 단말기는 '정적 응용 프로그램 데이터'와 '스마트카드의 공개키'를 확인
5. $(4)$에서 획득한 스마트카드의 공개키를 이용하여 $(2)$에서 스마트카드로부터 전달받은 데이터를 복호화. 스마트카드에서 전송한 데이터의 진위 여부를 확인하고 처리

## 생체인증 기술의 평가항목

| 특성 | 설명 |
|:-----:|:-----|
| 보편성 | 모든 사람이 가지고 있는 생체 특성인가? |
| 유일성 | 동일한 생체 특징을 가진 타인은 없는가? |
| 지속성(영구성) | 시간에 따른 변화가 없는 생체 특징인가? |
| 획득성 | 정량적으로 측정이 가능한 특성인가? |
| 성능 | 환경변화와 무관하게 높은 정확성을 얻을 수 있는가? |
| 수용성 | 사용자의 거부감은 없는가? |
| 반기만성 | 고의적인 부정사용으로부터 안전한가? |

## 생체인증의 정확성
![FRR](https://user-images.githubusercontent.com/41509536/90137890-35377c00-ddb1-11ea-84c4-0da95d18f000.png)

## 생체인식기반 간편 공인인증 가이드라인의 보안 요구사항
- 루팅, 탈옥 등 스마트폰이 불법 변경되면 모든 저장소에 접근이 가능하여 안전한 하드웨어 저장소를 활용할 것을 권고
- 비밀번호, 생체정보 등 전자서명생성정보 접근을 위한 로컬인증 실패 시 횟수를 제한
- 스마트폰 내 지문인식 장치의 FAR(오인식률)은 1/50,000을 지원해야 하며, FRR(오거부율)은 2~3% 이하를 지원해야 함
- 위조지문 등 스마트폰 내 지문인식 장치의 취약점이 발견되는 즉시 보안조치가 이루어져야 함
- TEE(Trusted Execution Environment, 신뢰된 실행 환경) 클라이언트와 TA(Trusted Application, 신뢰된 애플리케이션)는 신뢰된 상호인증을 수행하는 것을 권고

## CAPTCHA(Completely Automated Public Test to tell Computers and Humans Apart)
- 자동 계정생성 방지 기술
- 로봇프로그램과 사람을 구분하는 방법의 하나
- 사람이 인식할 수 있는 문자나 그림을 활용하여 자동 회원가입 및 게시글 포스팅을 방지하는데 사용하는 방법

## FIDO(Fast IDentity Online)
- 비밀번호의 문제점을 해결하기 위한 목적
- FIDO 얼라이언스에 의해 제안된 사용자 인증 프레임워크
- 인증 기법과 그 인증 정보를 주고받기 위한 인증 프로토콜을 분리하는 것이 핵심 아이디어
- 지문, 홍제 등 생체인증을 적용하기 위해 주로 사용
1. `UAF` : Universal Authentication Framework
	- 사용자 기기에서 제공하는 인증방법을 온라인 서비스와 연동해 인증하는 기술
	- 지문인식 기능을 통해 결제 서비스를 제공하는 **삼성페이**가 대표적
2. `U2F` : Universal 2nd Fator
	- 기존 아이디와 비밀번호 기반 온라인 서비스에서 추가로 인증을 받고자 할 때, 사용자의 로그인 시에 추가할 수 있는 프로토콜
	- **구글의 USB 보안키**를 활용한 방식이 대표적

## PAM(Pluggable Authentication Modules)
- 인증 모듈
- 컴퓨팅 시스템의 사용자 인증을 더욱 융통성 있고 다양한 방법으로 지원
- 인증 방법에 대한 함수를 포함한 라이브러리를 제공

## EAM(Extranet Acess Management)
- 인트라넷, 엑스트라넷 및 일반 클라이언트/서버 환경에서 자원의 접근 인증과 이를 기반으로 자원에 대한 접근 권한을 부여, 관리하는 통한 인증 관리 솔루션
- 하나의 ID와 암호 입력으로 다양한 시스템에 접근할 수 있고, 각 ID에 따라 사용 권한을 차등 부여하는 통합 인증과 권한 관리 시스템
- 차등적 접근 제어를 구현하기 위해서 시스템 관리자가 직원들의 접근 권한을 수작업으로 입력(시간 및 비용 손실이 큼)
- 일반 기업과 금융권, 포털 등 기업 내 사요자와 일반 사용자에게 적용 가능함
- 인터넷 뱅킹, 쇼핑 등 서비스 편의성과 운영비 절감 및 기업 내 보안 효과가 있음

## IAM(Identify and Access Management)
- 계정관리 전반 및 프로비저닝(Provisioning) 기능을 포함한 포괄적인 의미의 계정관리 솔루션
- 기업의 조직구조에 부합하도록 사용자들의 계정을 관리
- 모든 컴퓨팅 자원에 대한 사용자 접근을 통일된 정책/방법으로 관리하는 시스템
- 통합적이고 중앙집중적인 계정관리 서비스 제공
- 비용 대비 효율성 증가
- 강력한 보안 체계 구현
- 기존 EAM에 자동적 권한 부여 및 관리 기능을 추가한 것이 IAM

##  SSO, EAM, IAM 비교

| 구분 | SSO | EAM | IAM |
|:-----:|:-----|:-----|:-----|
| 관련 기술 | PKI, LDAP | SSO, AC, LDAP, PKI, 암호화 | 통합자원관리 + Provisioning |
| 특징 | 하나의 ID, PWD로 다양한 시스템 접근 | SSO + 정책기반 + 접근제어 | 기업 업무프로세스 근거한 사용자관리 및 접근제어 |
| 장단점 | 권한에 따른 접근제한기능 없음 | 시스템관리(권한제어)의 비용/시간 손실 발생 | 자동화된 자원관리로 확장 용이 |

공통점 : 기업 내 다양한 시스템의 접근 통합관리 보안 솔루션

## ERP(Enterprise Resource Planning)
- 전사적 자원계획
- 조직의 각종 경영활동에 필요한 자원들을 최적의 상태로 운영할 수 있도록 지원해주는 정보기술의 복합 응용 시스템

## SSO 장단점 비교

| 장점 | 단점 |
|:-----|:-----|
| - 운영비용 감소<br>- 보안성 강화<br>- 사용자 편의성 증가(PW 암기/분실 위험 감소)<br>- 중앙 집중 관리를 통한 효율적 관리 가능 | - SSO 서버가 단일실패지점<br>(SPoF, Single Point of Failure)<br>- SSO 서버 침해 시 모든 서버의 보안 침해 가능<br>- SSO 개발 및 운영비용 발생 |

## SSO 종류
1. `Delegation 방식` : **인증 대행**
2. `Propagation 방식` : **인증정보 전달**, 웹 환경에서의 SSO는 대부분 이 모델을 채택
3. `Delegation & Propagation 방식` : 두 방식을 혼용
4. `Web 기반 One Cookie Domain SSO방식`
	SSO 대상 서비스와 응용 애플리케이션들이 하나의 Cookie Domain 안에 존재할 때 사용되는 일반적인 기업 내부의 컴퓨팅 환경에서 사용
5. `Web 기반 Multi Cookie Domain SSO`
	SSO 대상 서비스와 응용 애플리케이션들이 여러 도메인으로 분산돼 있을 경우
	Multi Domain 환경인 경우에는 사용자 인증 및 토큰 발행을 위한 **마스터 에이전트**가 존재함

## SSO 방식
`SPNEGO`, `SESAME`, `Kerveros`

## 커버로스
- 네트워크상에서 클라이언트, 서버, KDC 세 통신주체 간에 인증 받은 사용자만이 적절한 통신을 할 수 있게 함
- 사용자가 인증서버에 처음 로그인할 때**만** 패스워드를 입력함

## 커버로스의 구성요소
| 구성요소 | 설명 | 비고 |
|:-----:|:-----|:-----:|
| KDC<br>(Key Distribution Center) | - 키 분배 서버(Kerberos 내에서 가장 중요한 시스템)<br>- 모든 사용자와 서비스들의 암호화키를 보유<br>- 신뢰할 수 있는 제3의 기관으로서 티켓을 생성, 인증서비스를 제공<br>- 클라이언트와 서비스는 KDC의 무결성을 신뢰하며, 이러한 신뢰는 커버로스 보안의 근간<br>- 사용자의 패스워드는 비밀키로 변환되고 이 비밀키는 주체와 KDC 사이에서 민감한 데이터를 전송하기 위해 사용됨, 사용자 인증 목적을 위해서도 사용됨 | TGS와 AS로 구성 |
| AS<br>(Authentication) | - 실질적으로 인증을 수행<br>- 사용자에 대한 인증을 수행하는 KDC의 부분 서비스 | |
| TGS<br>(Ticket Granting Service) | - 티켓 부여 서비스<br>- 티켓을 부여하고 티켓을 분배하는 KDC의 부분 서비스 | |
| Ticket | - 사용자에 대해 신원과 인증을 확인하는 토큰<br>- 사용자가 다른 주체들과 통신이 필요할 때마다 패스워드를 입력하지 않도록 도와줌 | |
| Principals | - 인증을 위하여 커버로스 프로토콜을 사용하는 모든 실체 | |

## 커버로스 프로토콜 인증 절차
1. 클라이언트는 서버에 접속하기 위해 인증서버와 인증(패스워드)을 시도한다.
2. 인증서버는 인증된 클라이언트에게 티켓 발급 서버로의 티켓 발급을 허용한다.
3. 티켓 발급 서버는 인증된 클라이언트에게 티켓을 발급한다.
4. 클라이언트는 이 티켓을 이용하여 서버에 접속한다.
5. 서버는 티켓을 확인한 후 클라이언트를 인증하여 접속을 허락한다.

## 커버로스의 장단점

| 장점 | 단점 |
|:-----|:-----|
| - 데이터의 기밀성과 무결성 보장<br>-재생공격 예방<br>-개방된 이기종 간의 컴퓨터에서 자유로운 인증이 가능(SSO)<br>-대칭키를 사용하여 도청으로부터 보호 | - 패스워드 사전공격에 약함<br>-비밀키, 세션키가 임시로 단말기에 저장되어 침입자에 의해 탈취당할 수 있음<br>-TimeStamp로 인해 시간동기화 프로토콜이 필요<br>- 비밀키 변경 필요<br>-KDC가 단일실패지점(SPoF)이 될 수 있음<br>-KDC는 많은 수의 요청을 처리 가능해야 함(즉, 확장 가능성이 있어야 함)<br>-TGS & AS는 물리적 공격 및 악성코드의 공격에 취약 |

## MAC, DAC, RBAC 비교

| 항목 | MAC | DAC | RBAC |
|:-----:|:-----:|:-----:|:-----:|
| 정의 | 주체와 객체의 등급을 비교하여 접근권한을 부여하는 접근통제 | 접근하고자 하는 주체의 신분에 따라 접근권한을 부여하는 접근통제 | 주체와 객체 사이에 역할을 부여하여 임의적, 강제적 접근통제의 약점을 보안한 방식 |
| 권한부여 | System | Data Owner | Central Authority |
| 접근결정 | Security Label | 신분 | 역할(Role) |
| 정책 | 경직 | 유연 | 유연 |
| 장점 | 중앙집중, 안정적 | 유연함, 구현 용이 | 관리용이 |
| 단점 | 구현 및 운영의 어려움<br>성능, 비용이 고가 | 트로이목마에 취약<br>ID 도용 시 통제 방법이 없음 | - |
| 적용 사례 | 방화벽 | ACL | HIPAA |

## 키 분배
- 한 사용자 또는 기관(KDC)이 비밀키(세션키)를 설정하여 다른 사용자에게 전달하는 기술
- `Needham-Schroeder` : 커버로스 등의 이론적 배경

## 키 합의
- 두 당사자 간에 준비된 키가 없더라도 안전하지 못한 채널을 통해서도 같은 비밀키(세션키)를 공유할 수 있게끔 일련의 패킷들을 교환해가며 대칭키를 합의하는 과정
- 직접적인 키 교환은 아니지만 특정 규칙에 의해 각자 비밀키를 생성하더라도 같은 비밀키를 갖게됨
- `Diffie-Hellman`, `Matsumoto-Takashima-Imai`, `Okamoto-Nakamura`
